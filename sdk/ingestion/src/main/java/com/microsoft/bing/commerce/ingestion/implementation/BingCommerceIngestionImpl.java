// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.microsoft.bing.commerce.ingestion.implementation;

import com.microsoft.bing.commerce.ingestion.BingCommerceIngestion;
import okhttp3.OkHttpClient;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.bing.commerce.ingestion.models.DeleteDocumentsResponse;
import com.microsoft.bing.commerce.ingestion.models.Index;
import com.microsoft.bing.commerce.ingestion.models.IndexResponse;
import com.microsoft.bing.commerce.ingestion.models.IndexStatusResponse;
import com.microsoft.bing.commerce.ingestion.models.PushDataUpdateResponse;
import com.microsoft.bing.commerce.ingestion.models.PushUpdateStatusResponse;
import com.microsoft.bing.commerce.ingestion.models.RequestsStringSet;
import com.microsoft.bing.commerce.ingestion.models.SchemaDetectionResponse;
import com.microsoft.bing.commerce.ingestion.models.TransformationConfigResponse;
import com.microsoft.bing.commerce.ingestion.models.TransformationTryoutResponse;

import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import com.microsoft.rest.ServiceClient;
import com.microsoft.rest.RestClient;

import java.io.IOException;

import okhttp3.ResponseBody;
import retrofit2.converter.scalars.ScalarsConverterFactory;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the BingCommerceIngestion class.
 */
public class BingCommerceIngestionImpl extends ServiceClient implements BingCommerceIngestion {
    /**
     * The Retrofit service to perform REST calls.
     */
    private BingCommerceIngestionService service;

    /**
     * Initializes an instance of BingCommerceIngestion client.
     */
    public BingCommerceIngestionImpl() {
        this("https://commerce.bing.com/api/ingestion/v1");
    }

    /**
     * Initializes an instance of BingCommerceIngestion client.
     *
     * @param baseUrl the base URL of the host
     */
    public BingCommerceIngestionImpl(String baseUrl) {
        super(baseUrl);
        initialize();
    }

    /**
     * Initializes an instance of BingCommerceIngestion client.
     *
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public BingCommerceIngestionImpl(OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        this("https://commerce.bing.com/api/ingestion/v1", clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of BingCommerceIngestion client.
     *
     * @param baseUrl the base URL of the host
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public BingCommerceIngestionImpl(String baseUrl, OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {

        super(baseUrl, clientBuilder, restBuilder.addConverterFactory(ScalarsConverterFactory.create()));
        initialize();
    }

    /**
     * Initializes an instance of BingCommerceIngestion client.
     *
     * @param restClient the REST client containing pre-configured settings
     */
    public BingCommerceIngestionImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    private void initialize() {
        initializeService();
    }

    private void initializeService() {
        service = retrofit().create(BingCommerceIngestionService.class); }

    /**
     * The interface defining all the services for BingCommerceIngestion to be
     * used by Retrofit to perform actually REST calls.
     */
    interface BingCommerceIngestionService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.commerce.ingestion.BingCommerceIngestion createIndex" })
        @POST("{tenantid}/indexes")
        Observable<Response<ResponseBody>> createIndex(@Path("tenantid") String tenantid, @Header("SubscriptionId") String subscriptionId, @Body Index body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.commerce.ingestion.BingCommerceIngestion getAllIndexes" })
        @GET("{tenantid}/indexes")
        Observable<Response<ResponseBody>> getAllIndexes(@Path("tenantid") String tenantid, @Header("SubscriptionId") String subscriptionId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.commerce.ingestion.BingCommerceIngestion deleteIndex" })
        @HTTP(path = "{tenantid}/indexes/{indexid}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteIndex(@Path("tenantid") String tenantid, @Path("indexid") String indexid, @Header("SubscriptionId") String subscriptionId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.commerce.ingestion.BingCommerceIngestion updateIndex" })
        @PUT("{tenantid}/indexes/{indexid}")
        Observable<Response<ResponseBody>> updateIndex(@Path("tenantid") String tenantid, @Path("indexid") String indexid, @Header("SubscriptionId") String subscriptionId, @Body Index body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.commerce.ingestion.BingCommerceIngestion getIndex" })
        @GET("{tenantid}/indexes/{indexid}")
        Observable<Response<ResponseBody>> getIndex(@Path("tenantid") String tenantid, @Path("indexid") String indexid, @Header("SubscriptionId") String subscriptionId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.commerce.ingestion.BingCommerceIngestion deleteDocuments" })
        @POST("{tenantid}/indexes/{indexid}/deletedata")
        Observable<Response<ResponseBody>> deleteDocuments(@Path("tenantid") String tenantid, @Path("indexid") String indexid, @Header("SubscriptionId") String subscriptionId, @Body RequestsStringSet body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.commerce.ingestion.BingCommerceIngestion getIndexStatus" })
        @GET("{tenantid}/indexes/{indexid}/status")
        Observable<Response<ResponseBody>> getIndexStatus(@Path("tenantid") String tenantid, @Path("indexid") String indexid, @Header("SubscriptionId") String subscriptionId);

        @Headers({ "Content-Type: text/plain", "x-ms-logging-context: com.microsoft.bing.commerce.ingestion.BingCommerceIngestion pushDataUpdate" })
        @POST("{tenantid}/indexes/{indexid}/pushdata")
        Observable<Response<ResponseBody>> pushDataUpdate(@Path("tenantid") String tenantid, @Path("indexid") String indexid, @Header("SubscriptionId") String subscriptionId, @Query("notransform") Boolean notransform, @Query("updateid") String updateid, @Body String body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.commerce.ingestion.BingCommerceIngestion pushDataStatus" })
        @GET("{tenantid}/indexes/{indexid}/status/{updateid}")
        Observable<Response<ResponseBody>> pushDataStatus(@Path("tenantid") String tenantid, @Path("indexid") String indexid, @Path("updateid") String updateid, @Header("SubscriptionId") String subscriptionId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.commerce.ingestion.BingCommerceIngestion deleteTransformationConfig" })
        @HTTP(path = "{tenantid}/indexes/{indexid}/transformation", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteTransformationConfig(@Path("tenantid") String tenantid, @Path("indexid") String indexid, @Header("SubscriptionId") String subscriptionId);

        @Headers({ "Content-Type: text/plain", "x-ms-logging-context: com.microsoft.bing.commerce.ingestion.BingCommerceIngestion createOrUpdateTransformationConfig" })
        @PUT("{tenantid}/indexes/{indexid}/transformation")
        Observable<Response<ResponseBody>> createOrUpdateTransformationConfig(@Path("tenantid") String tenantid, @Path("indexid") String indexid, @Header("SubscriptionId") String subscriptionId, @Body String body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.commerce.ingestion.BingCommerceIngestion getTransformationConfig" })
        @GET("{tenantid}/indexes/{indexid}/transformation")
        Observable<Response<ResponseBody>> getTransformationConfig(@Path("tenantid") String tenantid, @Path("indexid") String indexid, @Header("SubscriptionId") String subscriptionId);

        @Headers({ "Content-Type: text/plain", "x-ms-logging-context: com.microsoft.bing.commerce.ingestion.BingCommerceIngestion uploadTryOutConfig" })
        @POST("transformation/tryout")
        Observable<Response<ResponseBody>> uploadTryOutConfig(@Header("SubscriptionId") String subscriptionId, @Body String body);

        @Headers({ "Content-Type: text/plain", "x-ms-logging-context: com.microsoft.bing.commerce.ingestion.BingCommerceIngestion executeTryOutConfig" })
        @POST("transformation/tryout/{tryoutid}")
        Observable<Response<ResponseBody>> executeTryOutConfig(@Path("tryoutid") String tryoutid, @Header("SubscriptionId") String subscriptionId, @Body String body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.bing.commerce.ingestion.BingCommerceIngestion detectSchema" })
        @POST("schemadetection")
        Observable<Response<ResponseBody>> detectSchema(@Header("SubscriptionId") String subscriptionId, @Query("format") String format);

    }

    /**
     * Create an index.
     * Creates a definition of the tenant's index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexResponse object if successful.
     */
    public IndexResponse createIndex(String tenantid) {
        return createIndexWithServiceResponseAsync(tenantid).toBlocking().single().body();
    }

    /**
     * Create an index.
     * Creates a definition of the tenant's index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexResponse> createIndexAsync(String tenantid, final ServiceCallback<IndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(createIndexWithServiceResponseAsync(tenantid), serviceCallback);
    }

    /**
     * Create an index.
     * Creates a definition of the tenant's index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<IndexResponse> createIndexAsync(String tenantid) {
        return createIndexWithServiceResponseAsync(tenantid).map(new Func1<ServiceResponse<IndexResponse>, IndexResponse>() {
            @Override
            public IndexResponse call(ServiceResponse<IndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Create an index.
     * Creates a definition of the tenant's index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<ServiceResponse<IndexResponse>> createIndexWithServiceResponseAsync(String tenantid) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        final String subscriptionId = null;
        final Index body = null;
        return service.createIndex(tenantid, subscriptionId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexResponse> clientResponse = createIndexDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Create an index.
     * Creates a definition of the tenant's index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param subscriptionId Bing developer subcription id
     * @param body An Index object that describes the index definition to add.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexResponse object if successful.
     */
    public IndexResponse createIndex(String tenantid, String subscriptionId, Index body) {
        return createIndexWithServiceResponseAsync(tenantid, subscriptionId, body).toBlocking().single().body();
    }

    /**
     * Create an index.
     * Creates a definition of the tenant's index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param subscriptionId Bing developer subcription id
     * @param body An Index object that describes the index definition to add.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexResponse> createIndexAsync(String tenantid, String subscriptionId, Index body, final ServiceCallback<IndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(createIndexWithServiceResponseAsync(tenantid, subscriptionId, body), serviceCallback);
    }

    /**
     * Create an index.
     * Creates a definition of the tenant's index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param subscriptionId Bing developer subcription id
     * @param body An Index object that describes the index definition to add.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<IndexResponse> createIndexAsync(String tenantid, String subscriptionId, Index body) {
        return createIndexWithServiceResponseAsync(tenantid, subscriptionId, body).map(new Func1<ServiceResponse<IndexResponse>, IndexResponse>() {
            @Override
            public IndexResponse call(ServiceResponse<IndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Create an index.
     * Creates a definition of the tenant's index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param subscriptionId Bing developer subcription id
     * @param body An Index object that describes the index definition to add.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<ServiceResponse<IndexResponse>> createIndexWithServiceResponseAsync(String tenantid, String subscriptionId, Index body) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        Validator.validate(body);
        return service.createIndex(tenantid, subscriptionId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexResponse> clientResponse = createIndexDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IndexResponse> createIndexDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<IndexResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<IndexResponse>() { }.getType())
                .build(response);
    }

    /**
     * Get list of index definitions.
     * Get list of index definitions that you defined for a tenant.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexResponse object if successful.
     */
    public IndexResponse getAllIndexes(String tenantid) {
        return getAllIndexesWithServiceResponseAsync(tenantid).toBlocking().single().body();
    }

    /**
     * Get list of index definitions.
     * Get list of index definitions that you defined for a tenant.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexResponse> getAllIndexesAsync(String tenantid, final ServiceCallback<IndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(getAllIndexesWithServiceResponseAsync(tenantid), serviceCallback);
    }

    /**
     * Get list of index definitions.
     * Get list of index definitions that you defined for a tenant.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<IndexResponse> getAllIndexesAsync(String tenantid) {
        return getAllIndexesWithServiceResponseAsync(tenantid).map(new Func1<ServiceResponse<IndexResponse>, IndexResponse>() {
            @Override
            public IndexResponse call(ServiceResponse<IndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Get list of index definitions.
     * Get list of index definitions that you defined for a tenant.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<ServiceResponse<IndexResponse>> getAllIndexesWithServiceResponseAsync(String tenantid) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        final String subscriptionId = null;
        return service.getAllIndexes(tenantid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexResponse> clientResponse = getAllIndexesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get list of index definitions.
     * Get list of index definitions that you defined for a tenant.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexResponse object if successful.
     */
    public IndexResponse getAllIndexes(String tenantid, String subscriptionId) {
        return getAllIndexesWithServiceResponseAsync(tenantid, subscriptionId).toBlocking().single().body();
    }

    /**
     * Get list of index definitions.
     * Get list of index definitions that you defined for a tenant.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param subscriptionId Bing developer subcription id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexResponse> getAllIndexesAsync(String tenantid, String subscriptionId, final ServiceCallback<IndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(getAllIndexesWithServiceResponseAsync(tenantid, subscriptionId), serviceCallback);
    }

    /**
     * Get list of index definitions.
     * Get list of index definitions that you defined for a tenant.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<IndexResponse> getAllIndexesAsync(String tenantid, String subscriptionId) {
        return getAllIndexesWithServiceResponseAsync(tenantid, subscriptionId).map(new Func1<ServiceResponse<IndexResponse>, IndexResponse>() {
            @Override
            public IndexResponse call(ServiceResponse<IndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Get list of index definitions.
     * Get list of index definitions that you defined for a tenant.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<ServiceResponse<IndexResponse>> getAllIndexesWithServiceResponseAsync(String tenantid, String subscriptionId) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        return service.getAllIndexes(tenantid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexResponse> clientResponse = getAllIndexesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IndexResponse> getAllIndexesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<IndexResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<IndexResponse>() { }.getType())
                .build(response);
    }

    /**
     * Delete an index.
     * Delete an index definition along with all the catalog.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexResponse object if successful.
     */
    public IndexResponse deleteIndex(String tenantid, String indexid) {
        return deleteIndexWithServiceResponseAsync(tenantid, indexid).toBlocking().single().body();
    }

    /**
     * Delete an index.
     * Delete an index definition along with all the catalog.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexResponse> deleteIndexAsync(String tenantid, String indexid, final ServiceCallback<IndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(deleteIndexWithServiceResponseAsync(tenantid, indexid), serviceCallback);
    }

    /**
     * Delete an index.
     * Delete an index definition along with all the catalog.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<IndexResponse> deleteIndexAsync(String tenantid, String indexid) {
        return deleteIndexWithServiceResponseAsync(tenantid, indexid).map(new Func1<ServiceResponse<IndexResponse>, IndexResponse>() {
            @Override
            public IndexResponse call(ServiceResponse<IndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete an index.
     * Delete an index definition along with all the catalog.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<ServiceResponse<IndexResponse>> deleteIndexWithServiceResponseAsync(String tenantid, String indexid) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        final String subscriptionId = null;
        return service.deleteIndex(tenantid, indexid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexResponse> clientResponse = deleteIndexDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Delete an index.
     * Delete an index definition along with all the catalog.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexResponse object if successful.
     */
    public IndexResponse deleteIndex(String tenantid, String indexid, String subscriptionId) {
        return deleteIndexWithServiceResponseAsync(tenantid, indexid, subscriptionId).toBlocking().single().body();
    }

    /**
     * Delete an index.
     * Delete an index definition along with all the catalog.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexResponse> deleteIndexAsync(String tenantid, String indexid, String subscriptionId, final ServiceCallback<IndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(deleteIndexWithServiceResponseAsync(tenantid, indexid, subscriptionId), serviceCallback);
    }

    /**
     * Delete an index.
     * Delete an index definition along with all the catalog.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<IndexResponse> deleteIndexAsync(String tenantid, String indexid, String subscriptionId) {
        return deleteIndexWithServiceResponseAsync(tenantid, indexid, subscriptionId).map(new Func1<ServiceResponse<IndexResponse>, IndexResponse>() {
            @Override
            public IndexResponse call(ServiceResponse<IndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete an index.
     * Delete an index definition along with all the catalog.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<ServiceResponse<IndexResponse>> deleteIndexWithServiceResponseAsync(String tenantid, String indexid, String subscriptionId) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        return service.deleteIndex(tenantid, indexid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexResponse> clientResponse = deleteIndexDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IndexResponse> deleteIndexDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<IndexResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<IndexResponse>() { }.getType())
                .build(response);
    }

    /**
     * Updates an index with id.
     * Update the definition for your index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexResponse object if successful.
     */
    public IndexResponse updateIndex(String tenantid, String indexid) {
        return updateIndexWithServiceResponseAsync(tenantid, indexid).toBlocking().single().body();
    }

    /**
     * Updates an index with id.
     * Update the definition for your index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexResponse> updateIndexAsync(String tenantid, String indexid, final ServiceCallback<IndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(updateIndexWithServiceResponseAsync(tenantid, indexid), serviceCallback);
    }

    /**
     * Updates an index with id.
     * Update the definition for your index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<IndexResponse> updateIndexAsync(String tenantid, String indexid) {
        return updateIndexWithServiceResponseAsync(tenantid, indexid).map(new Func1<ServiceResponse<IndexResponse>, IndexResponse>() {
            @Override
            public IndexResponse call(ServiceResponse<IndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates an index with id.
     * Update the definition for your index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<ServiceResponse<IndexResponse>> updateIndexWithServiceResponseAsync(String tenantid, String indexid) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        final String subscriptionId = null;
        final Index body = null;
        return service.updateIndex(tenantid, indexid, subscriptionId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexResponse> clientResponse = updateIndexDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Updates an index with id.
     * Update the definition for your index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @param body The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexResponse object if successful.
     */
    public IndexResponse updateIndex(String tenantid, String indexid, String subscriptionId, Index body) {
        return updateIndexWithServiceResponseAsync(tenantid, indexid, subscriptionId, body).toBlocking().single().body();
    }

    /**
     * Updates an index with id.
     * Update the definition for your index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @param body The ID that uniquely identifies the index definition to manage.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexResponse> updateIndexAsync(String tenantid, String indexid, String subscriptionId, Index body, final ServiceCallback<IndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(updateIndexWithServiceResponseAsync(tenantid, indexid, subscriptionId, body), serviceCallback);
    }

    /**
     * Updates an index with id.
     * Update the definition for your index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @param body The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<IndexResponse> updateIndexAsync(String tenantid, String indexid, String subscriptionId, Index body) {
        return updateIndexWithServiceResponseAsync(tenantid, indexid, subscriptionId, body).map(new Func1<ServiceResponse<IndexResponse>, IndexResponse>() {
            @Override
            public IndexResponse call(ServiceResponse<IndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates an index with id.
     * Update the definition for your index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @param body The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<ServiceResponse<IndexResponse>> updateIndexWithServiceResponseAsync(String tenantid, String indexid, String subscriptionId, Index body) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        Validator.validate(body);
        return service.updateIndex(tenantid, indexid, subscriptionId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexResponse> clientResponse = updateIndexDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IndexResponse> updateIndexDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<IndexResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<IndexResponse>() { }.getType())
                .build(response);
    }

    /**
     * Get index definition by id.
     * Get a specific index definition for a tenant.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexResponse object if successful.
     */
    public IndexResponse getIndex(String tenantid, String indexid) {
        return getIndexWithServiceResponseAsync(tenantid, indexid).toBlocking().single().body();
    }

    /**
     * Get index definition by id.
     * Get a specific index definition for a tenant.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexResponse> getIndexAsync(String tenantid, String indexid, final ServiceCallback<IndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(getIndexWithServiceResponseAsync(tenantid, indexid), serviceCallback);
    }

    /**
     * Get index definition by id.
     * Get a specific index definition for a tenant.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<IndexResponse> getIndexAsync(String tenantid, String indexid) {
        return getIndexWithServiceResponseAsync(tenantid, indexid).map(new Func1<ServiceResponse<IndexResponse>, IndexResponse>() {
            @Override
            public IndexResponse call(ServiceResponse<IndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Get index definition by id.
     * Get a specific index definition for a tenant.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<ServiceResponse<IndexResponse>> getIndexWithServiceResponseAsync(String tenantid, String indexid) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        final String subscriptionId = null;
        return service.getIndex(tenantid, indexid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexResponse> clientResponse = getIndexDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get index definition by id.
     * Get a specific index definition for a tenant.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexResponse object if successful.
     */
    public IndexResponse getIndex(String tenantid, String indexid, String subscriptionId) {
        return getIndexWithServiceResponseAsync(tenantid, indexid, subscriptionId).toBlocking().single().body();
    }

    /**
     * Get index definition by id.
     * Get a specific index definition for a tenant.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexResponse> getIndexAsync(String tenantid, String indexid, String subscriptionId, final ServiceCallback<IndexResponse> serviceCallback) {
        return ServiceFuture.fromResponse(getIndexWithServiceResponseAsync(tenantid, indexid, subscriptionId), serviceCallback);
    }

    /**
     * Get index definition by id.
     * Get a specific index definition for a tenant.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<IndexResponse> getIndexAsync(String tenantid, String indexid, String subscriptionId) {
        return getIndexWithServiceResponseAsync(tenantid, indexid, subscriptionId).map(new Func1<ServiceResponse<IndexResponse>, IndexResponse>() {
            @Override
            public IndexResponse call(ServiceResponse<IndexResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Get index definition by id.
     * Get a specific index definition for a tenant.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexResponse object
     */
    public Observable<ServiceResponse<IndexResponse>> getIndexWithServiceResponseAsync(String tenantid, String indexid, String subscriptionId) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        return service.getIndex(tenantid, indexid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexResponse> clientResponse = getIndexDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IndexResponse> getIndexDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<IndexResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<IndexResponse>() { }.getType())
                .build(response);
    }

    /**
     * Delete documents from your catalog.
     * Delete documents from your index's catalog.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeleteDocumentsResponse object if successful.
     */
    public DeleteDocumentsResponse deleteDocuments(String tenantid, String indexid) {
        return deleteDocumentsWithServiceResponseAsync(tenantid, indexid).toBlocking().single().body();
    }

    /**
     * Delete documents from your catalog.
     * Delete documents from your index's catalog.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeleteDocumentsResponse> deleteDocumentsAsync(String tenantid, String indexid, final ServiceCallback<DeleteDocumentsResponse> serviceCallback) {
        return ServiceFuture.fromResponse(deleteDocumentsWithServiceResponseAsync(tenantid, indexid), serviceCallback);
    }

    /**
     * Delete documents from your catalog.
     * Delete documents from your index's catalog.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeleteDocumentsResponse object
     */
    public Observable<DeleteDocumentsResponse> deleteDocumentsAsync(String tenantid, String indexid) {
        return deleteDocumentsWithServiceResponseAsync(tenantid, indexid).map(new Func1<ServiceResponse<DeleteDocumentsResponse>, DeleteDocumentsResponse>() {
            @Override
            public DeleteDocumentsResponse call(ServiceResponse<DeleteDocumentsResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete documents from your catalog.
     * Delete documents from your index's catalog.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeleteDocumentsResponse object
     */
    public Observable<ServiceResponse<DeleteDocumentsResponse>> deleteDocumentsWithServiceResponseAsync(String tenantid, String indexid) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        final String subscriptionId = null;
        final RequestsStringSet body = null;
        return service.deleteDocuments(tenantid, indexid, subscriptionId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeleteDocumentsResponse>>>() {
                @Override
                public Observable<ServiceResponse<DeleteDocumentsResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeleteDocumentsResponse> clientResponse = deleteDocumentsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Delete documents from your catalog.
     * Delete documents from your index's catalog.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @param body The set of document ids to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DeleteDocumentsResponse object if successful.
     */
    public DeleteDocumentsResponse deleteDocuments(String tenantid, String indexid, String subscriptionId, RequestsStringSet body) {
        return deleteDocumentsWithServiceResponseAsync(tenantid, indexid, subscriptionId, body).toBlocking().single().body();
    }

    /**
     * Delete documents from your catalog.
     * Delete documents from your index's catalog.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @param body The set of document ids to delete.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DeleteDocumentsResponse> deleteDocumentsAsync(String tenantid, String indexid, String subscriptionId, RequestsStringSet body, final ServiceCallback<DeleteDocumentsResponse> serviceCallback) {
        return ServiceFuture.fromResponse(deleteDocumentsWithServiceResponseAsync(tenantid, indexid, subscriptionId, body), serviceCallback);
    }

    /**
     * Delete documents from your catalog.
     * Delete documents from your index's catalog.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @param body The set of document ids to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeleteDocumentsResponse object
     */
    public Observable<DeleteDocumentsResponse> deleteDocumentsAsync(String tenantid, String indexid, String subscriptionId, RequestsStringSet body) {
        return deleteDocumentsWithServiceResponseAsync(tenantid, indexid, subscriptionId, body).map(new Func1<ServiceResponse<DeleteDocumentsResponse>, DeleteDocumentsResponse>() {
            @Override
            public DeleteDocumentsResponse call(ServiceResponse<DeleteDocumentsResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete documents from your catalog.
     * Delete documents from your index's catalog.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @param body The set of document ids to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DeleteDocumentsResponse object
     */
    public Observable<ServiceResponse<DeleteDocumentsResponse>> deleteDocumentsWithServiceResponseAsync(String tenantid, String indexid, String subscriptionId, RequestsStringSet body) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        Validator.validate(body);
        return service.deleteDocuments(tenantid, indexid, subscriptionId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeleteDocumentsResponse>>>() {
                @Override
                public Observable<ServiceResponse<DeleteDocumentsResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeleteDocumentsResponse> clientResponse = deleteDocumentsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeleteDocumentsResponse> deleteDocumentsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<DeleteDocumentsResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DeleteDocumentsResponse>() { }.getType())
                .register(206, new TypeToken<DeleteDocumentsResponse>() { }.getType())
                .register(400, new TypeToken<DeleteDocumentsResponse>() { }.getType())
                .build(response);
    }

    /**
     * Get index status by id.
     * Get the detailed status of your index in each supported region.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexStatusResponse object if successful.
     */
    public IndexStatusResponse getIndexStatus(String tenantid, String indexid) {
        return getIndexStatusWithServiceResponseAsync(tenantid, indexid).toBlocking().single().body();
    }

    /**
     * Get index status by id.
     * Get the detailed status of your index in each supported region.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexStatusResponse> getIndexStatusAsync(String tenantid, String indexid, final ServiceCallback<IndexStatusResponse> serviceCallback) {
        return ServiceFuture.fromResponse(getIndexStatusWithServiceResponseAsync(tenantid, indexid), serviceCallback);
    }

    /**
     * Get index status by id.
     * Get the detailed status of your index in each supported region.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexStatusResponse object
     */
    public Observable<IndexStatusResponse> getIndexStatusAsync(String tenantid, String indexid) {
        return getIndexStatusWithServiceResponseAsync(tenantid, indexid).map(new Func1<ServiceResponse<IndexStatusResponse>, IndexStatusResponse>() {
            @Override
            public IndexStatusResponse call(ServiceResponse<IndexStatusResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Get index status by id.
     * Get the detailed status of your index in each supported region.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexStatusResponse object
     */
    public Observable<ServiceResponse<IndexStatusResponse>> getIndexStatusWithServiceResponseAsync(String tenantid, String indexid) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        final String subscriptionId = null;
        return service.getIndexStatus(tenantid, indexid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexStatusResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexStatusResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexStatusResponse> clientResponse = getIndexStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get index status by id.
     * Get the detailed status of your index in each supported region.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IndexStatusResponse object if successful.
     */
    public IndexStatusResponse getIndexStatus(String tenantid, String indexid, String subscriptionId) {
        return getIndexStatusWithServiceResponseAsync(tenantid, indexid, subscriptionId).toBlocking().single().body();
    }

    /**
     * Get index status by id.
     * Get the detailed status of your index in each supported region.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IndexStatusResponse> getIndexStatusAsync(String tenantid, String indexid, String subscriptionId, final ServiceCallback<IndexStatusResponse> serviceCallback) {
        return ServiceFuture.fromResponse(getIndexStatusWithServiceResponseAsync(tenantid, indexid, subscriptionId), serviceCallback);
    }

    /**
     * Get index status by id.
     * Get the detailed status of your index in each supported region.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexStatusResponse object
     */
    public Observable<IndexStatusResponse> getIndexStatusAsync(String tenantid, String indexid, String subscriptionId) {
        return getIndexStatusWithServiceResponseAsync(tenantid, indexid, subscriptionId).map(new Func1<ServiceResponse<IndexStatusResponse>, IndexStatusResponse>() {
            @Override
            public IndexStatusResponse call(ServiceResponse<IndexStatusResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Get index status by id.
     * Get the detailed status of your index in each supported region.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IndexStatusResponse object
     */
    public Observable<ServiceResponse<IndexStatusResponse>> getIndexStatusWithServiceResponseAsync(String tenantid, String indexid, String subscriptionId) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        return service.getIndexStatus(tenantid, indexid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IndexStatusResponse>>>() {
                @Override
                public Observable<ServiceResponse<IndexStatusResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IndexStatusResponse> clientResponse = getIndexStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IndexStatusResponse> getIndexStatusDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<IndexStatusResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<IndexStatusResponse>() { }.getType())
                .build(response);
    }

    /**
     * Push catalog data.
     * This method pushes updates to your your index data to Bing. This is an asynchronous process. To upload your index data to Bing, you'll send a push request that contains your index data.
     *
     * @param body the String value
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PushDataUpdateResponse object if successful.
     */
    public PushDataUpdateResponse pushDataUpdate(String body, String tenantid, String indexid) {
        return pushDataUpdateWithServiceResponseAsync(body, tenantid, indexid).toBlocking().single().body();
    }

    /**
     * Push catalog data.
     * This method pushes updates to your your index data to Bing. This is an asynchronous process. To upload your index data to Bing, you'll send a push request that contains your index data.
     *
     * @param body the String value
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PushDataUpdateResponse> pushDataUpdateAsync(String body, String tenantid, String indexid, final ServiceCallback<PushDataUpdateResponse> serviceCallback) {
        return ServiceFuture.fromResponse(pushDataUpdateWithServiceResponseAsync(body, tenantid, indexid), serviceCallback);
    }

    /**
     * Push catalog data.
     * This method pushes updates to your your index data to Bing. This is an asynchronous process. To upload your index data to Bing, you'll send a push request that contains your index data.
     *
     * @param body the String value
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushDataUpdateResponse object
     */
    public Observable<PushDataUpdateResponse> pushDataUpdateAsync(String body, String tenantid, String indexid) {
        return pushDataUpdateWithServiceResponseAsync(body, tenantid, indexid).map(new Func1<ServiceResponse<PushDataUpdateResponse>, PushDataUpdateResponse>() {
            @Override
            public PushDataUpdateResponse call(ServiceResponse<PushDataUpdateResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Push catalog data.
     * This method pushes updates to your your index data to Bing. This is an asynchronous process. To upload your index data to Bing, you'll send a push request that contains your index data.
     *
     * @param body the String value
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushDataUpdateResponse object
     */
    public Observable<ServiceResponse<PushDataUpdateResponse>> pushDataUpdateWithServiceResponseAsync(String body, String tenantid, String indexid) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        final String subscriptionId = null;
        final Boolean notransform = null;
        final String updateid = null;
        return service.pushDataUpdate(tenantid, indexid, subscriptionId, notransform, updateid, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PushDataUpdateResponse>>>() {
                @Override
                public Observable<ServiceResponse<PushDataUpdateResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PushDataUpdateResponse> clientResponse = pushDataUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Push catalog data.
     * This method pushes updates to your your index data to Bing. This is an asynchronous process. To upload your index data to Bing, you'll send a push request that contains your index data.
     *
     * @param body the String value
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @param notransform This disables transformation config processing if the config was uploaded for some index. It's useful when the data is already transformed and is matching the index definition. Default is `false`
     * @param updateid An id to uniquely identify the push update request in order to be able to track it down later.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PushDataUpdateResponse object if successful.
     */
    public PushDataUpdateResponse pushDataUpdate(String body, String tenantid, String indexid, String subscriptionId, Boolean notransform, String updateid) {
        return pushDataUpdateWithServiceResponseAsync(body, tenantid, indexid, subscriptionId, notransform, updateid).toBlocking().single().body();
    }

    /**
     * Push catalog data.
     * This method pushes updates to your your index data to Bing. This is an asynchronous process. To upload your index data to Bing, you'll send a push request that contains your index data.
     *
     * @param body the String value
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @param notransform This disables transformation config processing if the config was uploaded for some index. It's useful when the data is already transformed and is matching the index definition. Default is `false`
     * @param updateid An id to uniquely identify the push update request in order to be able to track it down later.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PushDataUpdateResponse> pushDataUpdateAsync(String body, String tenantid, String indexid, String subscriptionId, Boolean notransform, String updateid, final ServiceCallback<PushDataUpdateResponse> serviceCallback) {
        return ServiceFuture.fromResponse(pushDataUpdateWithServiceResponseAsync(body, tenantid, indexid, subscriptionId, notransform, updateid), serviceCallback);
    }

    /**
     * Push catalog data.
     * This method pushes updates to your your index data to Bing. This is an asynchronous process. To upload your index data to Bing, you'll send a push request that contains your index data.
     *
     * @param body the String value
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @param notransform This disables transformation config processing if the config was uploaded for some index. It's useful when the data is already transformed and is matching the index definition. Default is `false`
     * @param updateid An id to uniquely identify the push update request in order to be able to track it down later.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushDataUpdateResponse object
     */
    public Observable<PushDataUpdateResponse> pushDataUpdateAsync(String body, String tenantid, String indexid, String subscriptionId, Boolean notransform, String updateid) {
        return pushDataUpdateWithServiceResponseAsync(body, tenantid, indexid, subscriptionId, notransform, updateid).map(new Func1<ServiceResponse<PushDataUpdateResponse>, PushDataUpdateResponse>() {
            @Override
            public PushDataUpdateResponse call(ServiceResponse<PushDataUpdateResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Push catalog data.
     * This method pushes updates to your your index data to Bing. This is an asynchronous process. To upload your index data to Bing, you'll send a push request that contains your index data.
     *
     * @param body the String value
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @param notransform This disables transformation config processing if the config was uploaded for some index. It's useful when the data is already transformed and is matching the index definition. Default is `false`
     * @param updateid An id to uniquely identify the push update request in order to be able to track it down later.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushDataUpdateResponse object
     */
    public Observable<ServiceResponse<PushDataUpdateResponse>> pushDataUpdateWithServiceResponseAsync(String body, String tenantid, String indexid, String subscriptionId, Boolean notransform, String updateid) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        return service.pushDataUpdate(tenantid, indexid, subscriptionId, notransform, updateid, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PushDataUpdateResponse>>>() {
                @Override
                public Observable<ServiceResponse<PushDataUpdateResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PushDataUpdateResponse> clientResponse = pushDataUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PushDataUpdateResponse> pushDataUpdateDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PushDataUpdateResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PushDataUpdateResponse>() { }.getType())
                .build(response);
    }

    /**
     * .
     * .
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param updateid An id to uniquely identify the push update request in order to be able to track it down later.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PushUpdateStatusResponse object if successful.
     */
    public PushUpdateStatusResponse pushDataStatus(String tenantid, String indexid, String updateid) {
        return pushDataStatusWithServiceResponseAsync(tenantid, indexid, updateid).toBlocking().single().body();
    }

    /**
     * .
     * .
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param updateid An id to uniquely identify the push update request in order to be able to track it down later.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PushUpdateStatusResponse> pushDataStatusAsync(String tenantid, String indexid, String updateid, final ServiceCallback<PushUpdateStatusResponse> serviceCallback) {
        return ServiceFuture.fromResponse(pushDataStatusWithServiceResponseAsync(tenantid, indexid, updateid), serviceCallback);
    }

    /**
     * .
     * .
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param updateid An id to uniquely identify the push update request in order to be able to track it down later.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushUpdateStatusResponse object
     */
    public Observable<PushUpdateStatusResponse> pushDataStatusAsync(String tenantid, String indexid, String updateid) {
        return pushDataStatusWithServiceResponseAsync(tenantid, indexid, updateid).map(new Func1<ServiceResponse<PushUpdateStatusResponse>, PushUpdateStatusResponse>() {
            @Override
            public PushUpdateStatusResponse call(ServiceResponse<PushUpdateStatusResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * .
     * .
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param updateid An id to uniquely identify the push update request in order to be able to track it down later.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushUpdateStatusResponse object
     */
    public Observable<ServiceResponse<PushUpdateStatusResponse>> pushDataStatusWithServiceResponseAsync(String tenantid, String indexid, String updateid) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        if (updateid == null) {
            throw new IllegalArgumentException("Parameter updateid is required and cannot be null.");
        }
        final String subscriptionId = null;
        return service.pushDataStatus(tenantid, indexid, updateid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PushUpdateStatusResponse>>>() {
                @Override
                public Observable<ServiceResponse<PushUpdateStatusResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PushUpdateStatusResponse> clientResponse = pushDataStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * .
     * .
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param updateid An id to uniquely identify the push update request in order to be able to track it down later.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PushUpdateStatusResponse object if successful.
     */
    public PushUpdateStatusResponse pushDataStatus(String tenantid, String indexid, String updateid, String subscriptionId) {
        return pushDataStatusWithServiceResponseAsync(tenantid, indexid, updateid, subscriptionId).toBlocking().single().body();
    }

    /**
     * .
     * .
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param updateid An id to uniquely identify the push update request in order to be able to track it down later.
     * @param subscriptionId Bing developer subcription id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PushUpdateStatusResponse> pushDataStatusAsync(String tenantid, String indexid, String updateid, String subscriptionId, final ServiceCallback<PushUpdateStatusResponse> serviceCallback) {
        return ServiceFuture.fromResponse(pushDataStatusWithServiceResponseAsync(tenantid, indexid, updateid, subscriptionId), serviceCallback);
    }

    /**
     * .
     * .
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param updateid An id to uniquely identify the push update request in order to be able to track it down later.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushUpdateStatusResponse object
     */
    public Observable<PushUpdateStatusResponse> pushDataStatusAsync(String tenantid, String indexid, String updateid, String subscriptionId) {
        return pushDataStatusWithServiceResponseAsync(tenantid, indexid, updateid, subscriptionId).map(new Func1<ServiceResponse<PushUpdateStatusResponse>, PushUpdateStatusResponse>() {
            @Override
            public PushUpdateStatusResponse call(ServiceResponse<PushUpdateStatusResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * .
     * .
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param updateid An id to uniquely identify the push update request in order to be able to track it down later.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PushUpdateStatusResponse object
     */
    public Observable<ServiceResponse<PushUpdateStatusResponse>> pushDataStatusWithServiceResponseAsync(String tenantid, String indexid, String updateid, String subscriptionId) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        if (updateid == null) {
            throw new IllegalArgumentException("Parameter updateid is required and cannot be null.");
        }
        return service.pushDataStatus(tenantid, indexid, updateid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PushUpdateStatusResponse>>>() {
                @Override
                public Observable<ServiceResponse<PushUpdateStatusResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PushUpdateStatusResponse> clientResponse = pushDataStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PushUpdateStatusResponse> pushDataStatusDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PushUpdateStatusResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PushUpdateStatusResponse>() { }.getType())
                .build(response);
    }

    /**
     * Delete your index's transformation config.
     * Delete the transformation config that currently aplies to data you push to your index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationConfigResponse object if successful.
     */
    public TransformationConfigResponse deleteTransformationConfig(String tenantid, String indexid) {
        return deleteTransformationConfigWithServiceResponseAsync(tenantid, indexid).toBlocking().single().body();
    }

    /**
     * Delete your index's transformation config.
     * Delete the transformation config that currently aplies to data you push to your index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationConfigResponse> deleteTransformationConfigAsync(String tenantid, String indexid, final ServiceCallback<TransformationConfigResponse> serviceCallback) {
        return ServiceFuture.fromResponse(deleteTransformationConfigWithServiceResponseAsync(tenantid, indexid), serviceCallback);
    }

    /**
     * Delete your index's transformation config.
     * Delete the transformation config that currently aplies to data you push to your index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<TransformationConfigResponse> deleteTransformationConfigAsync(String tenantid, String indexid) {
        return deleteTransformationConfigWithServiceResponseAsync(tenantid, indexid).map(new Func1<ServiceResponse<TransformationConfigResponse>, TransformationConfigResponse>() {
            @Override
            public TransformationConfigResponse call(ServiceResponse<TransformationConfigResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete your index's transformation config.
     * Delete the transformation config that currently aplies to data you push to your index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<ServiceResponse<TransformationConfigResponse>> deleteTransformationConfigWithServiceResponseAsync(String tenantid, String indexid) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        final String subscriptionId = null;
        return service.deleteTransformationConfig(tenantid, indexid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransformationConfigResponse>>>() {
                @Override
                public Observable<ServiceResponse<TransformationConfigResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransformationConfigResponse> clientResponse = deleteTransformationConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Delete your index's transformation config.
     * Delete the transformation config that currently aplies to data you push to your index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationConfigResponse object if successful.
     */
    public TransformationConfigResponse deleteTransformationConfig(String tenantid, String indexid, String subscriptionId) {
        return deleteTransformationConfigWithServiceResponseAsync(tenantid, indexid, subscriptionId).toBlocking().single().body();
    }

    /**
     * Delete your index's transformation config.
     * Delete the transformation config that currently aplies to data you push to your index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationConfigResponse> deleteTransformationConfigAsync(String tenantid, String indexid, String subscriptionId, final ServiceCallback<TransformationConfigResponse> serviceCallback) {
        return ServiceFuture.fromResponse(deleteTransformationConfigWithServiceResponseAsync(tenantid, indexid, subscriptionId), serviceCallback);
    }

    /**
     * Delete your index's transformation config.
     * Delete the transformation config that currently aplies to data you push to your index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<TransformationConfigResponse> deleteTransformationConfigAsync(String tenantid, String indexid, String subscriptionId) {
        return deleteTransformationConfigWithServiceResponseAsync(tenantid, indexid, subscriptionId).map(new Func1<ServiceResponse<TransformationConfigResponse>, TransformationConfigResponse>() {
            @Override
            public TransformationConfigResponse call(ServiceResponse<TransformationConfigResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete your index's transformation config.
     * Delete the transformation config that currently aplies to data you push to your index.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<ServiceResponse<TransformationConfigResponse>> deleteTransformationConfigWithServiceResponseAsync(String tenantid, String indexid, String subscriptionId) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        return service.deleteTransformationConfig(tenantid, indexid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransformationConfigResponse>>>() {
                @Override
                public Observable<ServiceResponse<TransformationConfigResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransformationConfigResponse> clientResponse = deleteTransformationConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TransformationConfigResponse> deleteTransformationConfigDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<TransformationConfigResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TransformationConfigResponse>() { }.getType())
                .build(response);
    }

    /**
     * Retrieve your current index's transformation config.
     * Retrieve the transformation config that currently applies to data you push to your index.
     *
     * @param body the String value
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationConfigResponse object if successful.
     */
    public TransformationConfigResponse createOrUpdateTransformationConfig(String body, String tenantid, String indexid) {
        return createOrUpdateTransformationConfigWithServiceResponseAsync(body, tenantid, indexid).toBlocking().single().body();
    }

    /**
     * Retrieve your current index's transformation config.
     * Retrieve the transformation config that currently applies to data you push to your index.
     *
     * @param body the String value
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationConfigResponse> createOrUpdateTransformationConfigAsync(String body, String tenantid, String indexid, final ServiceCallback<TransformationConfigResponse> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateTransformationConfigWithServiceResponseAsync(body, tenantid, indexid), serviceCallback);
    }

    /**
     * Retrieve your current index's transformation config.
     * Retrieve the transformation config that currently applies to data you push to your index.
     *
     * @param body the String value
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<TransformationConfigResponse> createOrUpdateTransformationConfigAsync(String body, String tenantid, String indexid) {
        return createOrUpdateTransformationConfigWithServiceResponseAsync(body, tenantid, indexid).map(new Func1<ServiceResponse<TransformationConfigResponse>, TransformationConfigResponse>() {
            @Override
            public TransformationConfigResponse call(ServiceResponse<TransformationConfigResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieve your current index's transformation config.
     * Retrieve the transformation config that currently applies to data you push to your index.
     *
     * @param body the String value
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<ServiceResponse<TransformationConfigResponse>> createOrUpdateTransformationConfigWithServiceResponseAsync(String body, String tenantid, String indexid) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        final String subscriptionId = null;
        return service.createOrUpdateTransformationConfig(tenantid, indexid, subscriptionId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransformationConfigResponse>>>() {
                @Override
                public Observable<ServiceResponse<TransformationConfigResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransformationConfigResponse> clientResponse = createOrUpdateTransformationConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Retrieve your current index's transformation config.
     * Retrieve the transformation config that currently applies to data you push to your index.
     *
     * @param body the String value
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationConfigResponse object if successful.
     */
    public TransformationConfigResponse createOrUpdateTransformationConfig(String body, String tenantid, String indexid, String subscriptionId) {
        return createOrUpdateTransformationConfigWithServiceResponseAsync(body, tenantid, indexid, subscriptionId).toBlocking().single().body();
    }

    /**
     * Retrieve your current index's transformation config.
     * Retrieve the transformation config that currently applies to data you push to your index.
     *
     * @param body the String value
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationConfigResponse> createOrUpdateTransformationConfigAsync(String body, String tenantid, String indexid, String subscriptionId, final ServiceCallback<TransformationConfigResponse> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateTransformationConfigWithServiceResponseAsync(body, tenantid, indexid, subscriptionId), serviceCallback);
    }

    /**
     * Retrieve your current index's transformation config.
     * Retrieve the transformation config that currently applies to data you push to your index.
     *
     * @param body the String value
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<TransformationConfigResponse> createOrUpdateTransformationConfigAsync(String body, String tenantid, String indexid, String subscriptionId) {
        return createOrUpdateTransformationConfigWithServiceResponseAsync(body, tenantid, indexid, subscriptionId).map(new Func1<ServiceResponse<TransformationConfigResponse>, TransformationConfigResponse>() {
            @Override
            public TransformationConfigResponse call(ServiceResponse<TransformationConfigResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Retrieve your current index's transformation config.
     * Retrieve the transformation config that currently applies to data you push to your index.
     *
     * @param body the String value
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<ServiceResponse<TransformationConfigResponse>> createOrUpdateTransformationConfigWithServiceResponseAsync(String body, String tenantid, String indexid, String subscriptionId) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        return service.createOrUpdateTransformationConfig(tenantid, indexid, subscriptionId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransformationConfigResponse>>>() {
                @Override
                public Observable<ServiceResponse<TransformationConfigResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransformationConfigResponse> clientResponse = createOrUpdateTransformationConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TransformationConfigResponse> createOrUpdateTransformationConfigDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<TransformationConfigResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TransformationConfigResponse>() { }.getType())
                .build(response);
    }

    /**
     * Get ingestion status.
     * Track your ingestion by querying the status.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationConfigResponse object if successful.
     */
    public TransformationConfigResponse getTransformationConfig(String tenantid, String indexid) {
        return getTransformationConfigWithServiceResponseAsync(tenantid, indexid).toBlocking().single().body();
    }

    /**
     * Get ingestion status.
     * Track your ingestion by querying the status.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationConfigResponse> getTransformationConfigAsync(String tenantid, String indexid, final ServiceCallback<TransformationConfigResponse> serviceCallback) {
        return ServiceFuture.fromResponse(getTransformationConfigWithServiceResponseAsync(tenantid, indexid), serviceCallback);
    }

    /**
     * Get ingestion status.
     * Track your ingestion by querying the status.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<TransformationConfigResponse> getTransformationConfigAsync(String tenantid, String indexid) {
        return getTransformationConfigWithServiceResponseAsync(tenantid, indexid).map(new Func1<ServiceResponse<TransformationConfigResponse>, TransformationConfigResponse>() {
            @Override
            public TransformationConfigResponse call(ServiceResponse<TransformationConfigResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Get ingestion status.
     * Track your ingestion by querying the status.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<ServiceResponse<TransformationConfigResponse>> getTransformationConfigWithServiceResponseAsync(String tenantid, String indexid) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        final String subscriptionId = null;
        return service.getTransformationConfig(tenantid, indexid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransformationConfigResponse>>>() {
                @Override
                public Observable<ServiceResponse<TransformationConfigResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransformationConfigResponse> clientResponse = getTransformationConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get ingestion status.
     * Track your ingestion by querying the status.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationConfigResponse object if successful.
     */
    public TransformationConfigResponse getTransformationConfig(String tenantid, String indexid, String subscriptionId) {
        return getTransformationConfigWithServiceResponseAsync(tenantid, indexid, subscriptionId).toBlocking().single().body();
    }

    /**
     * Get ingestion status.
     * Track your ingestion by querying the status.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationConfigResponse> getTransformationConfigAsync(String tenantid, String indexid, String subscriptionId, final ServiceCallback<TransformationConfigResponse> serviceCallback) {
        return ServiceFuture.fromResponse(getTransformationConfigWithServiceResponseAsync(tenantid, indexid, subscriptionId), serviceCallback);
    }

    /**
     * Get ingestion status.
     * Track your ingestion by querying the status.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<TransformationConfigResponse> getTransformationConfigAsync(String tenantid, String indexid, String subscriptionId) {
        return getTransformationConfigWithServiceResponseAsync(tenantid, indexid, subscriptionId).map(new Func1<ServiceResponse<TransformationConfigResponse>, TransformationConfigResponse>() {
            @Override
            public TransformationConfigResponse call(ServiceResponse<TransformationConfigResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Get ingestion status.
     * Track your ingestion by querying the status.
     *
     * @param tenantid The ID that uniquely identifies the tenant that the index belongs to.
     * @param indexid The ID that uniquely identifies the index definition to manage.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<ServiceResponse<TransformationConfigResponse>> getTransformationConfigWithServiceResponseAsync(String tenantid, String indexid, String subscriptionId) {
        if (tenantid == null) {
            throw new IllegalArgumentException("Parameter tenantid is required and cannot be null.");
        }
        if (indexid == null) {
            throw new IllegalArgumentException("Parameter indexid is required and cannot be null.");
        }
        return service.getTransformationConfig(tenantid, indexid, subscriptionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransformationConfigResponse>>>() {
                @Override
                public Observable<ServiceResponse<TransformationConfigResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransformationConfigResponse> clientResponse = getTransformationConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TransformationConfigResponse> getTransformationConfigDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<TransformationConfigResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TransformationConfigResponse>() { }.getType())
                .build(response);
    }

    /**
     * Create a transformation config.
     * Upload a new transformation config and set it as the transformation config that applies to data you push to your index.
     *
     * @param body the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationConfigResponse object if successful.
     */
    public TransformationConfigResponse uploadTryOutConfig(String body) {
        return uploadTryOutConfigWithServiceResponseAsync(body).toBlocking().single().body();
    }

    /**
     * Create a transformation config.
     * Upload a new transformation config and set it as the transformation config that applies to data you push to your index.
     *
     * @param body the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationConfigResponse> uploadTryOutConfigAsync(String body, final ServiceCallback<TransformationConfigResponse> serviceCallback) {
        return ServiceFuture.fromResponse(uploadTryOutConfigWithServiceResponseAsync(body), serviceCallback);
    }

    /**
     * Create a transformation config.
     * Upload a new transformation config and set it as the transformation config that applies to data you push to your index.
     *
     * @param body the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<TransformationConfigResponse> uploadTryOutConfigAsync(String body) {
        return uploadTryOutConfigWithServiceResponseAsync(body).map(new Func1<ServiceResponse<TransformationConfigResponse>, TransformationConfigResponse>() {
            @Override
            public TransformationConfigResponse call(ServiceResponse<TransformationConfigResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a transformation config.
     * Upload a new transformation config and set it as the transformation config that applies to data you push to your index.
     *
     * @param body the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<ServiceResponse<TransformationConfigResponse>> uploadTryOutConfigWithServiceResponseAsync(String body) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        final String subscriptionId = null;
        return service.uploadTryOutConfig(subscriptionId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransformationConfigResponse>>>() {
                @Override
                public Observable<ServiceResponse<TransformationConfigResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransformationConfigResponse> clientResponse = uploadTryOutConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Create a transformation config.
     * Upload a new transformation config and set it as the transformation config that applies to data you push to your index.
     *
     * @param body the String value
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationConfigResponse object if successful.
     */
    public TransformationConfigResponse uploadTryOutConfig(String body, String subscriptionId) {
        return uploadTryOutConfigWithServiceResponseAsync(body, subscriptionId).toBlocking().single().body();
    }

    /**
     * Create a transformation config.
     * Upload a new transformation config and set it as the transformation config that applies to data you push to your index.
     *
     * @param body the String value
     * @param subscriptionId Bing developer subcription id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationConfigResponse> uploadTryOutConfigAsync(String body, String subscriptionId, final ServiceCallback<TransformationConfigResponse> serviceCallback) {
        return ServiceFuture.fromResponse(uploadTryOutConfigWithServiceResponseAsync(body, subscriptionId), serviceCallback);
    }

    /**
     * Create a transformation config.
     * Upload a new transformation config and set it as the transformation config that applies to data you push to your index.
     *
     * @param body the String value
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<TransformationConfigResponse> uploadTryOutConfigAsync(String body, String subscriptionId) {
        return uploadTryOutConfigWithServiceResponseAsync(body, subscriptionId).map(new Func1<ServiceResponse<TransformationConfigResponse>, TransformationConfigResponse>() {
            @Override
            public TransformationConfigResponse call(ServiceResponse<TransformationConfigResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a transformation config.
     * Upload a new transformation config and set it as the transformation config that applies to data you push to your index.
     *
     * @param body the String value
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationConfigResponse object
     */
    public Observable<ServiceResponse<TransformationConfigResponse>> uploadTryOutConfigWithServiceResponseAsync(String body, String subscriptionId) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        return service.uploadTryOutConfig(subscriptionId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransformationConfigResponse>>>() {
                @Override
                public Observable<ServiceResponse<TransformationConfigResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransformationConfigResponse> clientResponse = uploadTryOutConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TransformationConfigResponse> uploadTryOutConfigDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<TransformationConfigResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TransformationConfigResponse>() { }.getType())
                .build(response);
    }

    /**
     * Upload a trytout config.
     * Upload a transformation config that you can use to test data transformation on the cloud.
     *
     * @param body the String value
     * @param tryoutid The transformation tryout config id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationTryoutResponse object if successful.
     */
    public TransformationTryoutResponse executeTryOutConfig(String body, String tryoutid) {
        return executeTryOutConfigWithServiceResponseAsync(body, tryoutid).toBlocking().single().body();
    }

    /**
     * Upload a trytout config.
     * Upload a transformation config that you can use to test data transformation on the cloud.
     *
     * @param body the String value
     * @param tryoutid The transformation tryout config id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationTryoutResponse> executeTryOutConfigAsync(String body, String tryoutid, final ServiceCallback<TransformationTryoutResponse> serviceCallback) {
        return ServiceFuture.fromResponse(executeTryOutConfigWithServiceResponseAsync(body, tryoutid), serviceCallback);
    }

    /**
     * Upload a trytout config.
     * Upload a transformation config that you can use to test data transformation on the cloud.
     *
     * @param body the String value
     * @param tryoutid The transformation tryout config id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationTryoutResponse object
     */
    public Observable<TransformationTryoutResponse> executeTryOutConfigAsync(String body, String tryoutid) {
        return executeTryOutConfigWithServiceResponseAsync(body, tryoutid).map(new Func1<ServiceResponse<TransformationTryoutResponse>, TransformationTryoutResponse>() {
            @Override
            public TransformationTryoutResponse call(ServiceResponse<TransformationTryoutResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Upload a trytout config.
     * Upload a transformation config that you can use to test data transformation on the cloud.
     *
     * @param body the String value
     * @param tryoutid The transformation tryout config id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationTryoutResponse object
     */
    public Observable<ServiceResponse<TransformationTryoutResponse>> executeTryOutConfigWithServiceResponseAsync(String body, String tryoutid) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        if (tryoutid == null) {
            throw new IllegalArgumentException("Parameter tryoutid is required and cannot be null.");
        }
        final String subscriptionId = null;
        return service.executeTryOutConfig(tryoutid, subscriptionId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransformationTryoutResponse>>>() {
                @Override
                public Observable<ServiceResponse<TransformationTryoutResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransformationTryoutResponse> clientResponse = executeTryOutConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Upload a trytout config.
     * Upload a transformation config that you can use to test data transformation on the cloud.
     *
     * @param body the String value
     * @param tryoutid The transformation tryout config id.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TransformationTryoutResponse object if successful.
     */
    public TransformationTryoutResponse executeTryOutConfig(String body, String tryoutid, String subscriptionId) {
        return executeTryOutConfigWithServiceResponseAsync(body, tryoutid, subscriptionId).toBlocking().single().body();
    }

    /**
     * Upload a trytout config.
     * Upload a transformation config that you can use to test data transformation on the cloud.
     *
     * @param body the String value
     * @param tryoutid The transformation tryout config id.
     * @param subscriptionId Bing developer subcription id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TransformationTryoutResponse> executeTryOutConfigAsync(String body, String tryoutid, String subscriptionId, final ServiceCallback<TransformationTryoutResponse> serviceCallback) {
        return ServiceFuture.fromResponse(executeTryOutConfigWithServiceResponseAsync(body, tryoutid, subscriptionId), serviceCallback);
    }

    /**
     * Upload a trytout config.
     * Upload a transformation config that you can use to test data transformation on the cloud.
     *
     * @param body the String value
     * @param tryoutid The transformation tryout config id.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationTryoutResponse object
     */
    public Observable<TransformationTryoutResponse> executeTryOutConfigAsync(String body, String tryoutid, String subscriptionId) {
        return executeTryOutConfigWithServiceResponseAsync(body, tryoutid, subscriptionId).map(new Func1<ServiceResponse<TransformationTryoutResponse>, TransformationTryoutResponse>() {
            @Override
            public TransformationTryoutResponse call(ServiceResponse<TransformationTryoutResponse> response) {
                return response.body();
            }
        });
    }

    /**
     * Upload a trytout config.
     * Upload a transformation config that you can use to test data transformation on the cloud.
     *
     * @param body the String value
     * @param tryoutid The transformation tryout config id.
     * @param subscriptionId Bing developer subcription id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TransformationTryoutResponse object
     */
    public Observable<ServiceResponse<TransformationTryoutResponse>> executeTryOutConfigWithServiceResponseAsync(String body, String tryoutid, String subscriptionId) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        if (tryoutid == null) {
            throw new IllegalArgumentException("Parameter tryoutid is required and cannot be null.");
        }
        return service.executeTryOutConfig(tryoutid, subscriptionId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TransformationTryoutResponse>>>() {
                @Override
                public Observable<ServiceResponse<TransformationTryoutResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TransformationTryoutResponse> clientResponse = executeTryOutConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TransformationTryoutResponse> executeTryOutConfigDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<TransformationTryoutResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TransformationTryoutResponse>() { }.getType())
                .build(response);
    }

    /**
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SchemaDetectionResponse object if successful.
     */
    public SchemaDetectionResponse detectSchema() {
        return detectSchemaWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SchemaDetectionResponse> detectSchemaAsync(final ServiceCallback<SchemaDetectionResponse> serviceCallback) {
        return ServiceFuture.fromResponse(detectSchemaWithServiceResponseAsync(), serviceCallback);
    }

    /**
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SchemaDetectionResponse object
     */
    public Observable<SchemaDetectionResponse> detectSchemaAsync() {
        return detectSchemaWithServiceResponseAsync().map(new Func1<ServiceResponse<SchemaDetectionResponse>, SchemaDetectionResponse>() {
            @Override
            public SchemaDetectionResponse call(ServiceResponse<SchemaDetectionResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SchemaDetectionResponse object
     */
    public Observable<ServiceResponse<SchemaDetectionResponse>> detectSchemaWithServiceResponseAsync() {
        final String subscriptionId = null;
        final String format = null;
        return service.detectSchema(subscriptionId, format)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SchemaDetectionResponse>>>() {
                @Override
                public Observable<ServiceResponse<SchemaDetectionResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SchemaDetectionResponse> clientResponse = detectSchemaDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     *
     * @param subscriptionId Bing developer subcription id
     * @param format The push data update document format. Possible values include: 'Unknown', 'LDJson', 'CSV', 'TSV', 'JsonArray'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SchemaDetectionResponse object if successful.
     */
    public SchemaDetectionResponse detectSchema(String subscriptionId, String format) {
        return detectSchemaWithServiceResponseAsync(subscriptionId, format).toBlocking().single().body();
    }

    /**
     *
     * @param subscriptionId Bing developer subcription id
     * @param format The push data update document format. Possible values include: 'Unknown', 'LDJson', 'CSV', 'TSV', 'JsonArray'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SchemaDetectionResponse> detectSchemaAsync(String subscriptionId, String format, final ServiceCallback<SchemaDetectionResponse> serviceCallback) {
        return ServiceFuture.fromResponse(detectSchemaWithServiceResponseAsync(subscriptionId, format), serviceCallback);
    }

    /**
     *
     * @param subscriptionId Bing developer subcription id
     * @param format The push data update document format. Possible values include: 'Unknown', 'LDJson', 'CSV', 'TSV', 'JsonArray'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SchemaDetectionResponse object
     */
    public Observable<SchemaDetectionResponse> detectSchemaAsync(String subscriptionId, String format) {
        return detectSchemaWithServiceResponseAsync(subscriptionId, format).map(new Func1<ServiceResponse<SchemaDetectionResponse>, SchemaDetectionResponse>() {
            @Override
            public SchemaDetectionResponse call(ServiceResponse<SchemaDetectionResponse> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param subscriptionId Bing developer subcription id
     * @param format The push data update document format. Possible values include: 'Unknown', 'LDJson', 'CSV', 'TSV', 'JsonArray'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SchemaDetectionResponse object
     */
    public Observable<ServiceResponse<SchemaDetectionResponse>> detectSchemaWithServiceResponseAsync(String subscriptionId, String format) {
        return service.detectSchema(subscriptionId, format)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SchemaDetectionResponse>>>() {
                @Override
                public Observable<ServiceResponse<SchemaDetectionResponse>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SchemaDetectionResponse> clientResponse = detectSchemaDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SchemaDetectionResponse> detectSchemaDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<SchemaDetectionResponse, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<SchemaDetectionResponse>() { }.getType())
                .build(response);
    }

}